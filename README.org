* Leetcode Solutions in Java                                           :TOC_3:
  - [[#linked-list][Linked List]]
    - [[#linked-list-cycle][Linked List Cycle]]
    - [[#reverse-linked-list][Reverse Linked List]]
    - [[#remove-duplicates-from-sorted-list][Remove Duplicates from Sorted List]]
    - [[#merge-two-sorted-lists][Merge Two Sorted Lists]]
    - [[#palindrome-linked-list][Palindrome Linked List]]
    - [[#remove-linked-list-elements][Remove Linked List Elements]]
    - [[#intersection-of-two-linked-lists][Intersection of Two Linked Lists]]
    - [[#delete-node-in-a-linked-list][Delete Node in a Linked List]]
    - [[#add-two-numbers][Add Two Numbers]]
    - [[#add-two-numbers-ii][Add Two Numbers II]]
    - [[#odd-even-linked-list][Odd Even Linked List]]
    - [[#swap-nodes-in-pairs][Swap Nodes in Pairs]]
    - [[#convert-sorted-linked-list-to-binary-search-tree][Convert Sorted Linked List to Binary Search Tree]]
    - [[#remove-nth-node-from-end-of-list][Remove Nth Node From End of List]]
    - [[#insertion-sort-linked-list][Insertion Sort Linked List]]
    - [[#partition-linked-list][Partition Linked List]]
  - [[#dynamic-programming][Dynamic Programming]]
    - [[#maximum-subarray][Maximum Subarray]]
    - [[#maximum-profit][Maximum Profit]]
    - [[#climbing-stairs][Climbing Stairs]]
    - [[#house-robber][House Robber]]
    - [[#range-sum-query---immutable][Range Sum Query - Immutable]]
    - [[#counting-bits][Counting Bits]]

** Linked List
*** Linked List Cycle
#+BEGIN_QUOTE
Given a linked list, determine if it has a cycle in it.
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean hasCycle(ListNode head)
#+END_SRC

快慢指针法，块指针从head.next开始，慢指针从head开始，快指针每次移动两格，慢指针每次移动一格， 若两者能够相遇，则有环，否则，若在这个过程中检测到了链表尾，则无环。

*** Reverse Linked List
#+BEGIN_QUOTE
Reverse a linked list.

Challenge:
1. Reverse it in-place and in one-pass
2. A linked list can be reversed either iteratively or recursively. Could you implement both?
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode reverseList(ListNode head)
#+END_SRC

三个指针，依次往后移动。

*** Remove Duplicates from Sorted List
#+BEGIN_QUOTE
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode deleteDuplicates(ListNode head)
#+END_SRC

- A Recursive solution:
#+BEGIN_SRC Java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.next != null && head.val == head.next.val ? head.next : head;
}
#+END_SRC

*** Merge Two Sorted Lists
#+BEGIN_QUOTE
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode mergeTwoLists(ListNode l1, ListNode l2)
#+END_SRC

*** Palindrome Linked List
#+BEGIN_QUOTE
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean isPalindrome(ListNode head)
#+END_SRC
后半部分逆序，和前半部分依次比较，比较完成后将后半部分恢复，并和前半部分连接，以恢复原链表。

关于 ~O(1)~ 空间复杂度要求的讨论：

[[https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space/2][Reversing a list is not considered "O(1) space" | LeetCode Discuss]]

*** Remove Linked List Elements
#+BEGIN_QUOTE
Remove all elements from a linked list of integers that have value val.

Example:
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode removeElements(ListNode head, int val)
#+END_SRC

需要一个 ~dummy~ 节点，每次判断下一个节点的值。

*** Intersection of Two Linked Lists
#+BEGIN_QUOTE
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

: A:          a1 → a2
:                    ↘
:                      c1 → c2 → c3
:                    ↗            
: B:     b1 → b2 → b3

begin to intersect at node c1.


Notes:
1. If the two linked lists have no intersection at all, return null.
2. The linked lists must retain their original structure after the function returns.
3. You may assume there are no cycles anywhere in the entire linked structure.
4. Your code should preferably run in O(n) time and use only O(1) memory.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode getIntersectionNode(ListNode headA, ListNode headB)
#+END_SRC Java

思路：只要相交，则从某一个点开始到链表尾都是完全相同的，则先确定两个链表的长度，然后让长的链表先扫描，短的链表后扫描，使得两者能够同时到达链表尾，然后依次判断相应节点是否相同。

*** Delete Node in a Linked List
#+BEGIN_QUOTE
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.
#+END_QUOTE

#+BEGIN_SRC Java
public void deleteNode(ListNode node) 
#+END_SRC

本题在讨论区争议很大，因为只给出本节点的情况下是无法删除本节点的，只能通过 ~change value~ 来达到删除的作用。

*** Add Two Numbers
#+BEGIN_QUOTE
You are given two *non-empty* linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

*Example:*
: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
: Output: 7 -> 0 -> 8
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode addTwoNumbers(ListNode l1, ListNode l2)
#+END_SRC

本题数字是逆序存放的，因此便于依次从低位加到高位，需记录进位。

*** Add Two Numbers II
#+BEGIN_QUOTE
You are given two *non-empty* linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

*Follow up:*
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

*Example:*
: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
: Output: 7 -> 8 -> 0 -> 7
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode addTwoNumbers(ListNode l1, ListNode l2)
#+END_SRC

使用栈。第一次提交用了三个栈，每个加数和结果均对应一个，第二次提交仅用了两个栈，将结果的栈取消，构建链表的时候完成逆序。

*** Odd Even Linked List
#+BEGIN_QUOTE
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example:
: Given 1->2->3->4->5->NULL,
: return 1->3->5->2->4->NULL.

Note:
1. The relative order inside both the even and odd groups should remain as it was in the input. 
2. The first node is considered odd, the second node even and so on ...
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode oddEvenList(ListNode head)
#+END_SRC

注意边界条件。

*** Swap Nodes in Pairs
#+BEGIN_QUOTE
Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
#+END_QUOTE

#+BEGIN_SRC Java
public ListNode swapPairs(ListNode head)
#+END_SRC 

需加上一个前驱节点。

*** Convert Sorted Linked List to Binary Search Tree
#+BEGIN_QUOTE
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
#+END_QUOTE

#+BEGIN_SRC Java
public TreeNode sortedListToBST(ListNode head)
#+END_SRC

- 解决思路一：自顶而下 Recursive
找到中间节点，作为根节点，用左右链表分别构建左右子树，构建完成后分别连在根节点上。长度为 ~n~ 的链表找中间节点的时间复杂度为 ~O(n)~，则总的时间复杂度为 
: O(n) + O(n/2) * 2 + O(n/4) * 4 + ... = O(nlog(n))

- 解决思路二：自底而上
复杂度 ~O(n)~ 。

*** Remove Nth Node From End of List
#+BEGIN_QUOTE
Given a linked list, remove the nth node from the end of list and return its head.

*Example:*
: Given linked list: 1->2->3->4->5, and n = 2.
: After removing the second node from the end, the linked list becomes 1->2->3->5.

*Note:*
1. Given n will always be valid.
2. Try to do this in one pass.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode removeNthFromEnd(ListNode head, int n)
#+END_SRC

快慢指针法， =fast= 指针比 =slow= 指针先走 =n= 步，当 =fast= 指针指向链表尾时，慢指针的位置即为所要删除的位置，需加上一个 ~dummy~ 节点，因为当删除元素时，总是要获得其前驱的 =reference= 。

*** Insertion Sort Linked List
#+BEGIN_QUOTE 
Sort a linked list using insertion sort.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode insertionSortList(ListNode head)
#+END_SRC

*** Partition Linked List
#+BEGIN_QUOTE
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example,
: Given 1->4->3->2->5->2 and x = 3,
: return 1->2->2->4->3->5.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode partition(ListNode head, int x)
#+END_SRC

扫描一遍，两个链表分别记下小于 =x= 的和大于 =x= 的，最后拼起来。

** Dynamic Programming
*** Maximum Subarray
#+BEGIN_QUOTE
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4]
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

click to show more practice.

More practice:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
#+END_QUOTE

#+BEGIN_SRC Java
public static int maxSubArray(int[] nums)
#+END_SRC

=Kadane's algorithm=:
https://en.wikipedia.org/wiki/Maximum_subarray_problem

*** Maximum Profit
#+BEGIN_QUOTE
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Example 1:
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
Example 2:
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
#+END_QUOTE

#+BEGIN_SRC Java
public static int maxProfit(int[] prices)
#+END_SRC

实际上就是一个 =Maximum Subarray= 的问题，求差分向量的 =Maximum Subarray= 即可。

*** Climbing Stairs
#+BEGIN_QUOTE
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.
#+END_QUOTE

#+BEGIN_SRC Java
public int climbStairs(int n)
#+END_SRC

实际上是 =Fibonacci= 序列。

Leetcode 的解析中有 =log(n)= 时间复杂度的解法：
: https://leetcode.com/problems/climbing-stairs/solution/

*** House Robber
#+BEGIN_QUOTE
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
#+END_QUOTE

#+BEGIN_SRC Java
public static int rob(int[] nums)
#+END_SRC

递推关系式：
: f(0) = nums[0]
: f(1) = max(nums[0], nums[1])
: f(k) = max(f(k-2) + nums[k], f(k-1))

*** Range Sum Query - Immutable
#+BEGIN_QUOTE
Given an integer array nums, find the sum of the elements between indices i and j (i <= j), inclusive.

*Example:*
: Given nums = [-2, 0, 3, -5, 2, -1]

: sumRange(0, 2) -> 1
: sumRange(2, 5) -> -1
: sumRange(0, 5) -> -3

*Note:*
1. You may assume that the array does not change.
2. There are many calls to sumRange function.
#+END_QUOTE

#+BEGIN_SRC Java
class NumArray {
    public NumArray(int[] nums) {
    }

    public int sumRange(int i, int j) {
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(i,j);
 */
#+END_SRC

由于题目中提到了，会很多次调用 ~sumRange~ 函数，因此可在初始化时将累加结果算出，从而在调用 ~sumRange~ 时时间复杂度为 ~O(n)~ 。

*** Counting Bits
#+BEGIN_QUOTE
Given a non negative integer number num. For every numbers i in the range ~0 <= i <= num~ calculate the number of 1's in their binary representation and return them as an array.

*Example:*
For num = 5 you should return [0,1,1,2,1,2].

*Follow up:*
1. It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
2. Space complexity should be O(n).
3. Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
#+END_QUOTE

