* Leetcode Solutions in Java                                           :TOC_3:
  - [[#linked-list][Linked List]]
    - [[#linked-list-cycle][Linked List Cycle]]
    - [[#reverse-linked-list][Reverse Linked List]]
    - [[#remove-duplicates-from-sorted-list][Remove Duplicates from Sorted List]]
    - [[#merge-two-sorted-lists][Merge Two Sorted Lists]]
    - [[#palindrome-linked-list][Palindrome Linked List]]
  - [[#array][Array]]
  - [[#tree][Tree]]

** Linked List
*** Linked List Cycle
#+BEGIN_QUOTE
Given a linked list, determine if it has a cycle in it.
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean hasCycle(ListNode head)
#+END_SRC

快慢指针法，块指针从head.next开始，慢指针从head开始，快指针每次移动两
格，慢指针每次移动一格， 若两者能够相遇，则有环，否则，若在这个过程中
检测到了链表尾，则无环。

*** Reverse Linked List
#+BEGIN_QUOTE
Reverse a linked list.

Challenge:
1. Reverse it in-place and in one-pass
2. A linked list can be reversed either iteratively or recursively. Could you implement both?
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode reverseList(ListNode head)
#+END_SRC

三个指针，依次往后移动。

*** Remove Duplicates from Sorted List

- A Recursive solution:
#+BEGIN_SRC Java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.next != null && head.val == head.next.val ? head.next : head;
}
#+END_SRC

*** Merge Two Sorted Lists

*** Palindrome Linked List
#+BEGIN_QUOTE
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?
#+END_QUOTE

后半部分逆序，和前半部分依次比较，比较完成后将后半部分恢复，并和前半部
分连接，以恢复原链表。

关于 ~O(1)~ 空间复杂度要求的讨论：

[[https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space/2][Reversing a list is not considered "O(1) space" | LeetCode Discuss]]

** Array
** Tree
