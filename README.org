* Leetcode Solutions in Java                                           :TOC_3:
  - [[#linked-list][Linked List]]
    - [[#linked-list-cycle][Linked List Cycle]]
    - [[#reverse-linked-list][Reverse Linked List]]
    - [[#remove-duplicates-from-sorted-list][Remove Duplicates from Sorted List]]
    - [[#merge-two-sorted-lists][Merge Two Sorted Lists]]
    - [[#palindrome-linked-list][Palindrome Linked List]]
    - [[#remove-linked-list-elements][Remove Linked List Elements]]
    - [[#intersection-of-two-linked-lists][Intersection of Two Linked Lists]]
    - [[#delete-node-in-a-linked-list][Delete Node in a Linked List]]
    - [[#add-two-numbers][Add Two Numbers]]
    - [[#add-two-numbers-ii][Add Two Numbers II]]
    - [[#odd-even-linked-list][Odd Even Linked List]]
    - [[#swap-nodes-in-pairs][Swap Nodes in Pairs]]
    - [[#convert-sorted-linked-list-to-binary-search-tree][Convert Sorted Linked List to Binary Search Tree]]
  - [[#array][Array]]
  - [[#tree][Tree]]

** Linked List
*** Linked List Cycle
#+BEGIN_QUOTE
Given a linked list, determine if it has a cycle in it.
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean hasCycle(ListNode head)
#+END_SRC

快慢指针法，块指针从head.next开始，慢指针从head开始，快指针每次移动两格，慢指针每次移动一格， 若两者能够相遇，则有环，否则，若在这个过程中检测到了链表尾，则无环。

*** Reverse Linked List
#+BEGIN_QUOTE
Reverse a linked list.

Challenge:
1. Reverse it in-place and in one-pass
2. A linked list can be reversed either iteratively or recursively. Could you implement both?
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode reverseList(ListNode head)
#+END_SRC

三个指针，依次往后移动。

*** Remove Duplicates from Sorted List
#+BEGIN_QUOTE
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode deleteDuplicates(ListNode head)
#+END_SRC

- A Recursive solution:
#+BEGIN_SRC Java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.next != null && head.val == head.next.val ? head.next : head;
}
#+END_SRC

*** Merge Two Sorted Lists
#+BEGIN_QUOTE
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode mergeTwoLists(ListNode l1, ListNode l2)
#+END_SRC

*** Palindrome Linked List
#+BEGIN_QUOTE
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean isPalindrome(ListNode head)
#+END_SRC
后半部分逆序，和前半部分依次比较，比较完成后将后半部分恢复，并和前半部分连接，以恢复原链表。

关于 ~O(1)~ 空间复杂度要求的讨论：

[[https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space/2][Reversing a list is not considered "O(1) space" | LeetCode Discuss]]

*** Remove Linked List Elements
#+BEGIN_QUOTE
Remove all elements from a linked list of integers that have value val.

Example:
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode removeElements(ListNode head, int val)
#+END_SRC

需要一个 ~dummy~ 节点，每次判断下一个节点的值。

*** Intersection of Two Linked Lists
#+BEGIN_QUOTE
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

: A:          a1 → a2
:                    K
:                      c1 → c2 → c3
:                    J            
: B:     b1 → b2 → b3

begin to intersect at node c1.


Notes:
1. If the two linked lists have no intersection at all, return null.
2. The linked lists must retain their original structure after the function returns.
3. You may assume there are no cycles anywhere in the entire linked structure.
4. Your code should preferably run in O(n) time and use only O(1) memory.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode getIntersectionNode(ListNode headA, ListNode headB)
#+END_SRC Java

思路：只要相交，则从某一个点开始到链表尾都是完全相同的，则先确定两个链表的长度，然后让长的链表先扫描，短的链表后扫描，使得两者能够同时到达链表尾，然后依次判断相应节点是否相同。

*** Delete Node in a Linked List
#+BEGIN_QUOTE
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.
#+END_QUOTE

#+BEGIN_SRC Java
public void deleteNode(ListNode node) 
#+END_SRC

本题在讨论区争议很大，因为只给出本节点的情况下是无法删除本节点的，只能通过 ~change value~ 来达到删除的作用。

*** Add Two Numbers
#+BEGIN_QUOTE
You are given two *non-empty* linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

*Example:*
: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
: Output: 7 -> 0 -> 8
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode addTwoNumbers(ListNode l1, ListNode l2)
#+END_SRC

本题数字是逆序存放的，因此便于依次从低位加到高位，需记录进位。

*** Add Two Numbers II
#+BEGIN_QUOTE
You are given two *non-empty* linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

*Follow up:*
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

*Example:*
: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
: Output: 7 -> 8 -> 0 -> 7
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode addTwoNumbers(ListNode l1, ListNode l2)
#+END_SRC

使用栈。第一次提交用了三个栈，每个加数和结果均对应一个，第二次提交仅用了两个栈，将结果的栈取消，构建链表的时候完成逆序。

*** Odd Even Linked List
#+BEGIN_QUOTE
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example:
: Given 1->2->3->4->5->NULL,
: return 1->3->5->2->4->NULL.

Note:
1. The relative order inside both the even and odd groups should remain as it was in the input. 
2. The first node is considered odd, the second node even and so on ...
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode oddEvenList(ListNode head)
#+END_SRC

注意边界条件。

*** Swap Nodes in Pairs
#+BEGIN_QUOTE
Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
#+END_QUOTE

#+BEGIN_SRC Java
public ListNode swapPairs(ListNode head)
#+END_SRC 

需加上一个前驱节点。

*** Convert Sorted Linked List to Binary Search Tree
#+BEGIN_QUOTE
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
#+END_QUOTE

#+BEGIN_SRC Java
public TreeNode sortedListToBST(ListNode head)
#+END_SRC

- 解决思路一：自顶而下 Recursive
找到中间节点，作为根节点，用左右链表分别构建左右子树，构建完成后分别连在根节点上。长度为 \(n\） 的链表找中间节点的时间复杂度为 \(O(n)\)，则总的时间复杂度为 
\begin{equation}
O(n) + O(n/2) * 2 + O(n/4) * 4 + ... = nlg(n)
\end{equation}


** Array
** Tree
