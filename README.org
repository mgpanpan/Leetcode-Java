* Leetcode Solutions in Java                                           :TOC_3:
  - [[#linked-list][Linked List]]
    - [[#linked-list-cycle][Linked List Cycle]]
    - [[#reverse-linked-list][Reverse Linked List]]
    - [[#remove-duplicates-from-sorted-list][Remove Duplicates from Sorted List]]
    - [[#merge-two-sorted-lists][Merge Two Sorted Lists]]
    - [[#palindrome-linked-list][Palindrome Linked List]]
    - [[#remove-linked-list-elements][Remove Linked List Elements]]
  - [[#array][Array]]
  - [[#tree][Tree]]

** Linked List
*** Linked List Cycle
#+BEGIN_QUOTE
Given a linked list, determine if it has a cycle in it.
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean hasCycle(ListNode head)
#+END_SRC

快慢指针法，块指针从head.next开始，慢指针从head开始，快指针每次移动两格，慢指针每次移动一格， 若两者能够相遇，则有环，否则，若在这个过程中检测到了链表尾，则无环。

*** Reverse Linked List
#+BEGIN_QUOTE
Reverse a linked list.

Challenge:
1. Reverse it in-place and in one-pass
2. A linked list can be reversed either iteratively or recursively. Could you implement both?
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode reverseList(ListNode head)
#+END_SRC

三个指针，依次往后移动。

*** Remove Duplicates from Sorted List
#+BEGIN_QUOTE
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode deleteDuplicates(ListNode head)
#+END_SRC

- A Recursive solution:
#+BEGIN_SRC Java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.next != null && head.val == head.next.val ? head.next : head;
}
#+END_SRC

*** Merge Two Sorted Lists
#+BEGIN_QUOTE
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode mergeTwoLists(ListNode l1, ListNode l2)
#+END_SRC

*** Palindrome Linked List
#+BEGIN_QUOTE
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean isPalindrome(ListNode head)
#+END_SRC
后半部分逆序，和前半部分依次比较，比较完成后将后半部分恢复，并和前半部分连接，以恢复原链表。

关于 ~O(1)~ 空间复杂度要求的讨论：

[[https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space/2][Reversing a list is not considered "O(1) space" | LeetCode Discuss]]

*** Remove Linked List Elements
#+BEGIN_QUOTE
Remove all elements from a linked list of integers that have value val.

Example:
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode removeElements(ListNode head, int val)
#+END_SRC

** Array
** Tree
