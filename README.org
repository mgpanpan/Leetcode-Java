* Leetcode Solutions in Java                                           :TOC_3:
  - [[#linked-list][Linked List]]
    - [[#linked-list-cycle][Linked List Cycle]]
    - [[#reverse-linked-list][Reverse Linked List]]
    - [[#remove-duplicates-from-sorted-list][Remove Duplicates from Sorted List]]
    - [[#merge-two-sorted-lists][Merge Two Sorted Lists]]
    - [[#palindrome-linked-list][Palindrome Linked List]]
    - [[#remove-linked-list-elements][Remove Linked List Elements]]
    - [[#intersection-of-two-linked-lists][Intersection of Two Linked Lists]]
    - [[#delete-node-in-a-linked-list][Delete Node in a Linked List]]
    - [[#add-two-numbers][Add Two Numbers]]
    - [[#add-two-numbers-ii][Add Two Numbers II]]
  - [[#array][Array]]
  - [[#tree][Tree]]

** Linked List
*** Linked List Cycle
#+BEGIN_QUOTE
Given a linked list, determine if it has a cycle in it.
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean hasCycle(ListNode head)
#+END_SRC

快慢指针法，块指针从head.next开始，慢指针从head开始，快指针每次移动两格，慢指针每次移动一格， 若两者能够相遇，则有环，否则，若在这个过程中检测到了链表尾，则无环。

*** Reverse Linked List
#+BEGIN_QUOTE
Reverse a linked list.

Challenge:
1. Reverse it in-place and in one-pass
2. A linked list can be reversed either iteratively or recursively. Could you implement both?
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode reverseList(ListNode head)
#+END_SRC

三个指针，依次往后移动。

*** Remove Duplicates from Sorted List
#+BEGIN_QUOTE
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode deleteDuplicates(ListNode head)
#+END_SRC

- A Recursive solution:
#+BEGIN_SRC Java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.next != null && head.val == head.next.val ? head.next : head;
}
#+END_SRC

*** Merge Two Sorted Lists
#+BEGIN_QUOTE
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode mergeTwoLists(ListNode l1, ListNode l2)
#+END_SRC

*** Palindrome Linked List
#+BEGIN_QUOTE
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?
#+END_QUOTE

#+BEGIN_SRC Java
public static boolean isPalindrome(ListNode head)
#+END_SRC
后半部分逆序，和前半部分依次比较，比较完成后将后半部分恢复，并和前半部分连接，以恢复原链表。

关于 ~O(1)~ 空间复杂度要求的讨论：

[[https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space/2][Reversing a list is not considered "O(1) space" | LeetCode Discuss]]

*** Remove Linked List Elements
#+BEGIN_QUOTE
Remove all elements from a linked list of integers that have value val.

Example:
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode removeElements(ListNode head, int val)
#+END_SRC

需要一个 ~dummy~ 节点，每次判断下一个节点的值。

*** Intersection of Two Linked Lists
#+BEGIN_QUOTE
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

: A:          a1 → a2
:                    K
:                      c1 → c2 → c3
:                    J            
: B:     b1 → b2 → b3

begin to intersect at node c1.


Notes:
1. If the two linked lists have no intersection at all, return null.
2. The linked lists must retain their original structure after the function returns.
3. You may assume there are no cycles anywhere in the entire linked structure.
4. Your code should preferably run in O(n) time and use only O(1) memory.
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode getIntersectionNode(ListNode headA, ListNode headB)
#+END_SRC Java

思路：只要相交，则从某一个点开始到链表尾都是完全相同的，则先确定两个链表的长度，然后让长的链表先扫描，短的链表后扫描，使得两者能够同时到达链表尾，然后依次判断相应节点是否相同。

*** Delete Node in a Linked List
#+BEGIN_QUOTE
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.
#+END_QUOTE

#+BEGIN_SRC Java
public void deleteNode(ListNode node) 
#+END_SRC

本题在讨论区争议很大，因为只给出本节点的情况下是无法删除本节点的，只能通过 ~change value~ 来达到删除的作用。

*** Add Two Numbers
#+BEGIN_QUOTE
You are given two *non-empty* linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

*Example:*
: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
: Output: 7 -> 0 -> 8
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode addTwoNumbers(ListNode l1, ListNode l2)
#+END_SRC

本题数字是逆序存放的，因此便于依次从低位加到高位，需记录进位。

*** Add Two Numbers II
#+BEGIN_QUOTE
You are given two *non-empty* linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

*Follow up:*
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

*Example:*
: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
: Output: 7 -> 8 -> 0 -> 7
#+END_QUOTE

#+BEGIN_SRC Java
public static ListNode addTwoNumbers(ListNode l1, ListNode l2)
#+END_SRC

使用栈。
** Array
** Tree
